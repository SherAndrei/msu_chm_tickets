\section{Вычислительная погрешность. Устойчивость задачи и численного алгоритма.}

Определим вычислительную погрешность и машинную точность.
Для этого нам понадобятся основы машинной арифметики.

Наиболее распространенная форма представления действительных чисел в
компьютерах - числа с плавающей точкой. Множество $F$ чисел с плавающей
точкой характеризуется четырьмя параметрами: основанием системы
счисления $p$, разрядностью $t$ и интервалом показателей $[L;U]$. Каждое
число $x$, принадлежащее $F$, представимо в виде

\[x=\pm\left(\frac{d_1}{p}+\frac{d_2}{p^2}+\ldots+\frac{d_t}{p^t}\right)p^{\alpha};\ 0\leq d_i\leq p-1;\ i=1,\ldots,t;L\leq\alpha\leq U\]

$d_i$ называют \textit{разрядами}, $t$ - \textit{длиной мантиссы}, $\alpha$ - \textit{порядком числа}.
\textit{Мантиссой} (дробной частью) $x$ называют число в скобках.
Множество $F$ называют \textit{нормализованным} если $\forall\ x\neq0\Rightarrow d_1\neq0$.

\begin{example}
  $p=10,\ i=6$
  \[x = 1723,4835=+\left(\frac{1}{10}+\frac{7}{10^2}+\frac{2}{10^3}+\frac{3}{10^4}+\frac{4}{10^5}+\frac{8}{10^6}\right)10^4=0,172348\cdot10^4\]
\end{example}

Округление чисел при работе на компьютере с точностью $\varepsilon$ это
некоторое отображение $float:\R \rightarrow F$ удовлетворяющее условию:
\[\forall\ y\in\R,\ float(y)\in F,\ float(y)\neq0\rightarrow float(y)=y\cdot(1+\eta),|\eta|<\varepsilon\]

Таким образом относительная погрешность
\[\left|\frac{float(y)-y}{float(y)}\right|=\left|\frac{y\cdot(1+\eta)-y}{y}\right|=\left|\eta\right|\leq\varepsilon\equiv\const\]

Если $\varepsilon$ точная верхняя грань для $|\eta|$,
то при традиционном способе округления чисел имеем $\varepsilon=\frac{1}{2}p^{1-t}$,
при округлении отбрасыванием разрядов $\varepsilon=p^{1-t}$.
Величину $\varepsilon$ часто называют \textit{машинной точностью}.

Aлгоритмы, традиционно применяемые в точной арифметике,
могут некорректно работать при расчетах из-за конечной точности
на ЭВМ. Как следствие, к методам и постановкам задач вычислительной
математики предъявляют дополнительные требования.

\begin{enumerate}
  \item Решаемая численно задача должна быть устойчива, т.е. малое
        изменение входных параметров не должно значительно менять результат;
        \begin{example}[Неустойчивая задача]
          Рассотрим возмущенную матрицу Уилкинсона
          \[
            A(\varepsilon)=\left(\begin{array}{cccccc}
                20          & 20 &    &        &  & 0  \\
                            & 19 & 20 &        &  &    \\
                            &    & 18 & \ddots &  &    \\
                            &    &    & \ddots &  &    \\
                0           &    &    &        &  & 20 \\
                \varepsilon & 0  &    &        &  & 1
              \end{array}\right)
          \]
          Определитель этой матрицы (считаем по столбцам) равен
          \[\det(A(\varepsilon))=20!-\varepsilon\cdot20^{19}\]
          Характеристический многочлен матрицы
          \[\det(A(\varepsilon)-\lambda I)=(20-\lambda)\cdots(1-\lambda) - 20^{19}\varepsilon\]
          При $\varepsilon=0$ $\det(A(0))=20!$, а минимальное собственное число $\lambda_{min}=1$.
          Рассмотрим $\varepsilon=20^{-19}\cdot20!\approx5\cdot10^{-7}$:
          \[\det(A(5\cdot10^{-7}))\approx0\]
          То есть при достаточно малом $\varepsilon$ определитель
          матрицы изменился на $20!$, а величина наименьшего собственного значения стала равна $0$.

          Таким образом вычисление определителя является неустойчивой задачей,
          так как \textit{незначительная погрешность во входных данных может
            существенно исказить ответ}.
        \end{example}
  \item Выбранный алгоритм должен быть численно устойчив, т.е.
        ошибки округления в промежуточных вычислениях не должны искажать
        окончательный ответ;
        \begin{example}[Численно неустойчивый алгоритм]
          Вычисляется сумма $\sum_{i=1}^{10^3}1/i^2$. Какой алгоритм даст большую точность?
          \[S_0=0;\ S_n=S_{n-1}+\frac{1}{n^2},\ n=1,\ldots,10^3\]
          или
          \[R_{10^3+1}=0;\ R_{n-1}=R_n+\frac{1}{n^2},\ n=10^3,\ldots,1\]

          Рассмотрим более простой пример: в компьютерной арифметике
          надо сложить два числа при $t=5,p=10$:
          \[float(100,01) + float(0,0001)=0,10001\cdot10^3 +0,10000\cdot10^{-3}=float(100,0101)=0,10001\cdot10^3\]
          То есть сложение чисел разного порядка может привести к потере точности.

          Возвращаясь к задаче: следует воспользоваться вторым
          способом. При вычислении первым способом происходит
          потеря точности в результате сложения чисел $S_{n-1}$ и $1/n^2$,
          существенно отличающихся по величине.
        \end{example}
  \item Имеющиеся вычислительные ресурсы (память, быстродействие,
        программное обеспечение) должны позволить реализовать алгоритм и получить ответ за требуемое время.
        \begin{example}[Непозволительно долгий алгоритм]
          Метод Крамера решения систем линейных алгебраических уравнений с невырожденной матрицей
          $n \times n$ позволяет найти точное решение, вычислив $(n + 1)$ определитель матриц размерности $n \times n$.
          Оценим $T(n)$ - время работы алгоритма.

          Вычисление одного определителя методом миноров реализуется за $\sim nn!$
          арифметических действий, для вычисления $(n + 1)$ определителя потребуется
          $N \sim n(n + 1)!$ арифметических действий. Например, для $n = 20, 100$ имеем:
          \[20!\approx2.4\cdot10^{18},\ N(20)\approx10^{21};100!\approx10^{158},\ N(100)\approx10^{162}\]
          На современных компьютерах для выполнения $N(20)$ операций потребуется $3\cdot10^{139}$ лет.
        \end{example}
\end{enumerate}
